"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["581680"],{86081:function(e,t,n){n.r(t),n.d(t,{default:()=>u,frontMatter:()=>a,metadata:()=>i,assets:()=>s,toc:()=>l,contentTitle:()=>d});var i=JSON.parse('{"id":"data-operate/update/update-overview","title":"Updating Overview","description":"\x3c!--","source":"@site/versioned_docs/version-2.0/data-operate/update/update-overview.md","sourceDirName":"data-operate/update","slug":"/data-operate/update/update-overview","permalink":"/docs/2.0/data-operate/update/update-overview","draft":false,"unlisted":false,"tags":[],"version":"2.0","frontMatter":{"title":"Updating Overview","language":"en"},"sidebar":"docs","previous":{"title":"Loading Strict Mode","permalink":"/docs/2.0/data-operate/import/load-strict-mode"},"next":{"title":"Updating Data with UPDATE Command","permalink":"/docs/2.0/data-operate/update/unique-update"}}'),r=n("785893"),o=n("250065");let a={title:"Updating Overview",language:"en"},d=void 0,s={},l=[{value:"Comparison of Update Capabilities for Different Models/Implementations",id:"comparison-of-update-capabilities-for-different-modelsimplementations",level:2},{value:"Performance Comparison",id:"performance-comparison",level:3},{value:"Feature Support Comparison",id:"feature-support-comparison",level:3},{value:"Update in Primary Key (Unique) Model",id:"update-in-primary-key-unique-model",level:2},{value:"Two Update Methods in Unique Key Model",id:"two-update-methods-in-unique-key-model",level:3},{value:"<code>UPDATE</code> statement",id:"update-statement",level:4},{value:"Batch update based on load",id:"batch-update-based-on-load",level:4},{value:"Concurrency Control for Primary Key Model Updates",id:"concurrency-control-for-primary-key-model-updates",level:3},{value:"Using <code>UPDATE</code> Statements to Update Data",id:"using-update-statements-to-update-data",level:4},{value:"Batch Updates Based on Load",id:"batch-updates-based-on-load",level:4},{value:"Update in Aggregate Model",id:"update-in-aggregate-model",level:2},{value:"Recommendations for Choosing Between Primary Key and Aggregate Models",id:"recommendations-for-choosing-between-primary-key-and-aggregate-models",level:2}];function c(e){let t={a:"a",admonition:"admonition",br:"br",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:"Data update refers to modifying the value columns in data records with the same key. The handling of data updates varies for different data models:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Primary Key (Unique) Model"}),": The primary key model is specifically designed for data updates. Doris supports two storage implementations: Merge-on-Read (MoR) and Merge-on-Write (MoW). MoR optimizes write performance, while MoW provides better analytical performance. In Doris version 2.0, the default storage method is MoR. The primary key model supports using the ",(0,r.jsx)(t.code,{children:"UPDATE"}),' statement for small data updates and also supports batch updates through data loading. Loading methods include Stream Load, Broker Load, Routine Load, and Insert Into, all following the "UPSERT" semantics, meaning if the record does not exist, it is inserted; if it exists, it is updated. Update operations support both full row updates and partial column updates, with full row updates being the default.']}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Aggregate Model"}),": In the aggregate model, data update is a special use case. When the aggregate function is set to REPLACE or REPLACE_IF_NOT_NULL, data updates can be achieved. The aggregate model only supports updates based on data loading and does not support using the ",(0,r.jsx)(t.code,{children:"UPDATE"})," statement. By setting the aggregate function to REPLACE_IF_NOT_NOT_NULL, partial column update capability can be achieved."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"By understanding the data update methods of different models, you can better choose the appropriate update strategy to meet specific business needs."}),"\n",(0,r.jsx)(t.h2,{id:"comparison-of-update-capabilities-for-different-modelsimplementations",children:"Comparison of Update Capabilities for Different Models/Implementations"}),"\n",(0,r.jsx)(t.h3,{id:"performance-comparison",children:"Performance Comparison"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{}),(0,r.jsx)(t.th,{children:"Unique Key MoW"}),(0,r.jsx)(t.th,{children:"Unique Key MoR"}),(0,r.jsx)(t.th,{children:"Aggregate Key"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Import Speed"}),(0,r.jsx)(t.td,{children:"Deduplication is performed during import. Small-batch real-time writes incur approximately 10%-20% performance loss compared to MoR, while large-batch imports (e.g., tens or hundreds of millions of records) have about 30%-50% performance loss compared to MoR."}),(0,r.jsx)(t.td,{children:"Similar to Duplicate Key"}),(0,r.jsx)(t.td,{children:"Similar to Duplicate Key"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Query Speed"}),(0,r.jsx)(t.td,{children:"Similar to Duplicate Key"}),(0,r.jsx)(t.td,{children:"Requires deduplication during queries, with query time approximately 3-10 times that of MoW"}),(0,r.jsx)(t.td,{children:"If the aggregation function is REPLACE/REPLACE_IF_NOT_NULL, query speed is similar to MoR"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Predicate Pushdown"}),(0,r.jsx)(t.td,{children:"Supported"}),(0,r.jsx)(t.td,{children:"Not Supported"}),(0,r.jsx)(t.td,{children:"Not Supported"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Resource Consumption"}),(0,r.jsxs)(t.td,{children:["- ",(0,r.jsx)(t.strong,{children:"Import Resource Consumption"}),": Consumes approximately 10%-30% more CPU compared to Duplicate Key/Unique Key MoR.",(0,r.jsx)(t.br,{})," - ",(0,r.jsx)(t.strong,{children:"Query Resource Consumption"}),": Similar to Duplicate Key with no additional resource consumption.",(0,r.jsx)(t.br,{})," - ",(0,r.jsx)(t.strong,{children:"Compaction Resource Consumption"}),": Higher memory and CPU usage compared to Duplicate Key, specific usage depends on data characteristics and volume."]}),(0,r.jsxs)(t.td,{children:["- ",(0,r.jsx)(t.strong,{children:"Import Resource Consumption"}),": Similar to Duplicate Key with no additional resource consumption.",(0,r.jsx)(t.br,{})," - ",(0,r.jsx)(t.strong,{children:"Query Resource Consumption"}),": Higher CPU and memory consumption during queries compared to Duplicate Key/Unique Key MoW.",(0,r.jsx)(t.br,{})," - ",(0,r.jsx)(t.strong,{children:"Compaction Resource Consumption"}),": Higher memory and CPU usage than Duplicate Key, specific usage depends on data characteristics and volume."]}),(0,r.jsx)(t.td,{children:"Same as Unique Key MoR"})]})]})]}),"\n",(0,r.jsx)(t.h3,{id:"feature-support-comparison",children:"Feature Support Comparison"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{}),(0,r.jsx)(t.th,{children:"Unique Key MoW"}),(0,r.jsx)(t.th,{children:"Unique Key MoR"}),(0,r.jsx)(t.th,{children:"Aggregate Key"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"UPDATE"}),(0,r.jsx)(t.td,{children:"Supported"}),(0,r.jsx)(t.td,{children:"Supported"}),(0,r.jsx)(t.td,{children:"Not Supported"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"DELETE"}),(0,r.jsx)(t.td,{children:"Supported"}),(0,r.jsx)(t.td,{children:"Supported"}),(0,r.jsx)(t.td,{children:"Not Supported"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"sequence column"}),(0,r.jsx)(t.td,{children:"Supported"}),(0,r.jsx)(t.td,{children:"Supported"}),(0,r.jsx)(t.td,{children:"Not Supported"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"delete_sign"}),(0,r.jsx)(t.td,{children:"Supported"}),(0,r.jsx)(t.td,{children:"Supported"}),(0,r.jsx)(t.td,{children:"Not Supported"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Partial Column Updates"}),(0,r.jsx)(t.td,{children:"Supported"}),(0,r.jsx)(t.td,{children:"Not Supported"}),(0,r.jsx)(t.td,{children:"Supported (can't update null value)"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Inverted Index"}),(0,r.jsx)(t.td,{children:"Supported"}),(0,r.jsx)(t.td,{children:"Not Supported"}),(0,r.jsx)(t.td,{children:"Not Supported"})]})]})]}),"\n",(0,r.jsx)(t.h2,{id:"update-in-primary-key-unique-model",children:"Update in Primary Key (Unique) Model"}),"\n",(0,r.jsx)(t.p,{children:"Starting from Doris 2.0, Doris primary key (unique) model supports both Merge-on-Read (MoR) and Merge-on-Write (MoW) storage modes. MoR is optimized for write operations, while MoW is optimized for faster analysis performance. In actual tests, the analysis performance of MoW storage can be 5-10 times faster than MoR."}),"\n",(0,r.jsx)(t.p,{children:'By default, in Doris 2.0, the unique key model is still based on MoR. To create a MoW model, you need to manually specify the parameter "enable_unique_key_merge_on_write" as "true". Here\'s an example:'}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-sql",children:'CREATE TABLE IF NOT EXISTS example_tbl_unique_merge_on_write\n(\n  `user_id` LARGEINT NOT NULL,\n  `username` VARCHAR(50) NOT NULL ,\n  `city` VARCHAR(20),\n  `age` SMALLINT,\n  `sex` TINYINT,\n  `phone` LARGEINT,\n  `address` VARCHAR(500),\n  `register_time` DATETIME\n)\nUNIQUE KEY(`user_id`, `username`)\nDISTRIBUTED BY HASH(`user_id`) BUCKETS 1\nPROPERTIES (\n"replication_allocation" = "tag.location.default: 1",\n"enable_unique_key_merge_on_write" = "true"\n);\n'})}),"\n",(0,r.jsx)(t.admonition,{type:"caution",children:(0,r.jsx)(t.p,{children:"Starting from Doris 2.1, MoW is the default mode for the unique key model. So, if you are using Doris 2.1 or higher version, make sure to read the relevant table creation documentation."})}),"\n",(0,r.jsx)(t.h3,{id:"two-update-methods-in-unique-key-model",children:"Two Update Methods in Unique Key Model"}),"\n",(0,r.jsxs)(t.h4,{id:"update-statement",children:[(0,r.jsx)(t.code,{children:"UPDATE"})," statement"]}),"\n",(0,r.jsx)(t.p,{children:"Whether it is MoR or MoW, the semantics ensure that the specified columns are updated. The time taken for a single UPDATE operation increases with the amount of data being updated."}),"\n",(0,r.jsx)(t.h4,{id:"batch-update-based-on-load",children:"Batch update based on load"}),"\n",(0,r.jsx)(t.p,{children:'Doris supports multiple data load methods, including Stream Load, Broker Load, Routine Load, and Insert Into. For primary key tables, all load operations default to "UPSERT" semantics: if a record with the same key does not exist, it is inserted; if it already exists, it is updated. There are two types of updates: full row updates and partial column updates.'}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Full Row Update"}),": Updates for Unique Key tables default to full row updates. During data loading, users can choose to provide either all fields or only part of them. If only partial fields are provided, Doris will fill in the missing fields with default values to form a complete record for updating."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Partial Column Update"}),": Unique Key MoW supports partial column updates. Users can enable this feature by setting the session variable ",(0,r.jsx)(t.code,{children:"enable_unique_key_partial_update = true"})," or by specifying ",(0,r.jsx)(t.code,{children:"partial_columns:true"})," in the HTTP Header. When enabled, if a record with the given primary key exists, only the specified fields are updated; if the primary key does not exist, the missing fields are filled with default values."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["We will provide detailed explanations of these two update methods in the documentation: ",(0,r.jsx)(t.a,{href:"../update/unique-update",children:"Update in Unique Key Model"})," and ",(0,r.jsx)(t.a,{href:"../update/update-of-unique-model",children:"Load Update in Unique Key Model"}),"."]}),"\n",(0,r.jsx)(t.h3,{id:"concurrency-control-for-primary-key-model-updates",children:"Concurrency Control for Primary Key Model Updates"}),"\n",(0,r.jsxs)(t.h4,{id:"using-update-statements-to-update-data",children:["Using ",(0,r.jsx)(t.code,{children:"UPDATE"})," Statements to Update Data"]}),"\n",(0,r.jsxs)(t.p,{children:["By default, Doris does not allow multiple ",(0,r.jsx)(t.code,{children:"UPDATE"})," operations on the same table at the same time. The ",(0,r.jsx)(t.code,{children:"UPDATE"})," statement ensures isolation through table-level locking."]}),"\n",(0,r.jsxs)(t.p,{children:["Users can adjust the concurrency limit by modifying the FE configuration ",(0,r.jsx)(t.code,{children:"enable_concurrent_update=true"}),". When the concurrency limit is relaxed, if multiple ",(0,r.jsx)(t.code,{children:"UPDATE"})," statements update the same row of data, the result will be undefined."]}),"\n",(0,r.jsx)(t.h4,{id:"batch-updates-based-on-load",children:"Batch Updates Based on Load"}),"\n",(0,r.jsx)(t.p,{children:"Doris provides atomicity for all load update operations\u2014each data load will either be fully applied or fully rolled back."}),"\n",(0,r.jsx)(t.p,{children:"For concurrent load updates, Doris determines the order of concurrent updates using an internal version control system (assigned based on the order of completed loading), using an MVCC mechanism."}),"\n",(0,r.jsxs)(t.p,{children:["Since the commit order of multiple concurrent load updates may be unpredictable, if these concurrent load jobs involve updates to the same primary key, the order in which they take effect is also uncertain. As a result, the final visible outcome may be indeterminate. To address this issue, Doris provides a ",(0,r.jsx)(t.code,{children:"sequence"})," column mechanism, allowing users to specify a version for each row in concurrent load updates, thus ensuring determinism in the outcome of concurrent updates."]}),"\n",(0,r.jsxs)(t.p,{children:["For more detailed information on concurrency control, refer to the documentation on ",(0,r.jsx)(t.a,{href:"/docs/2.0/data-operate/update/unique-update-concurrent-control",children:"Concurrency Control for Updates in the Primary Key Model"}),"."]}),"\n",(0,r.jsx)(t.h2,{id:"update-in-aggregate-model",children:"Update in Aggregate Model"}),"\n",(0,r.jsx)(t.p,{children:"The update in the aggregate model refers to the process of generating new aggregate values by combining new column values with existing aggregate values, according to the requirements of the aggregate functions."}),"\n",(0,r.jsx)(t.p,{children:"New Agg Value = Agg Func (Old Agg Value, New Column Value)"}),"\n",(0,r.jsxs)(t.p,{children:["The update in the aggregate model is only supported through load methods and does not support the use of Update statements. When defining a table in the aggregate model, if the aggregation function for the value column is defined as REPLACE_IF_NOT_NULL, it indirectly achieves partial column update capabilities similar to the unique key model. For more details, please refer to the documentation on ",(0,r.jsx)(t.a,{href:"../update/update-of-aggregate-model",children:"Load Update in the Aggregate Model"}),"."]}),"\n",(0,r.jsx)(t.h2,{id:"recommendations-for-choosing-between-primary-key-and-aggregate-models",children:"Recommendations for Choosing Between Primary Key and Aggregate Models"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["For most scenarios that require data updates, it is recommended to ",(0,r.jsx)(t.strong,{children:"prefer the primary key model"}),". Examples include synchronizing from TP databases to Doris via CDC, user profiling, and audience targeting."]}),"\n",(0,r.jsxs)(t.li,{children:["The following scenarios are recommended to use the aggregate model:\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsx)(t.li,{children:"Some fields need to be aggregated as metrics, while others need to be updated."}),"\n",(0,r.jsx)(t.li,{children:"Scenarios where partial column updates are needed, while being very sensitive to write performance and having low requirements for query latency, it is recommended to use the aggregate table with the REPLACE_IF_NOT_NULL aggregate function."}),"\n"]}),"\n"]}),"\n"]})]})}function u(e={}){let{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},250065:function(e,t,n){n.d(t,{Z:function(){return d},a:function(){return a}});var i=n(667294);let r={},o=i.createContext(r);function a(e){let t=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);
"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["19637"],{367988:function(e,t,n){n.r(t),n.d(t,{default:()=>d,frontMatter:()=>r,metadata:()=>a,assets:()=>o,toc:()=>l,contentTitle:()=>c});var a=JSON.parse('{"id":"query/query-cache/query-cache","title":"Query Caches Overview","description":"\x3c!--","source":"@site/versioned_docs/version-2.0/query/query-cache/query-cache.md","sourceDirName":"query/query-cache","slug":"/query/query-cache/","permalink":"/docs/2.0/query/query-cache/","draft":false,"unlisted":false,"tags":[],"version":"2.0","frontMatter":{"title":"Query Caches Overview","language":"en"},"sidebar":"docs","previous":{"title":"Pipeline Execution Engine","permalink":"/docs/2.0/query/pipeline-execution-engine"},"next":{"title":"SQL Cache","permalink":"/docs/2.0/query/query-cache/sql-cache-manual"}}'),i=n("785893"),s=n("250065");let r={title:"Query Caches Overview",language:"en"},c=void 0,o={},l=[{value:"Demand scenario",id:"demand-scenario",level:2},{value:"solution",id:"solution",level:2},{value:"scenes to be used",id:"scenes-to-be-used",level:2},{value:"Monitoring",id:"monitoring",level:2},{value:"Related parameters",id:"related-parameters",level:2}];function h(e){let t={code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h2,{id:"demand-scenario",children:"Demand scenario"}),"\n",(0,i.jsx)(t.p,{children:"Most data analysis scenarios are to write less and read more. The data is written once and read multiple times frequently. For example, the dimensions and indicators involved in a report are calculated once in the early morning, but hundreds or even thousands of times a day. Page access, so it is very suitable for caching the result set. In data analysis or BI applications, the following business scenarios exist:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"High concurrency scenario"}),", Doris can better support high concurrency, but a single server cannot carry too high QPS"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Complex Chart Kanban"}),", complex Dashboard or large-screen application, data comes from multiple tables, and each page has dozens of queries. Although each query only takes tens of milliseconds, the overall query time will be several seconds."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Trend Analysis"}),", for queries within a given date range, indicators are displayed on a daily basis, such as querying the trend of the number of users in the last 7 days. This type of query has a large amount of data, a wide query range, and the query time often takes tens of seconds."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"User repeated query"}),", if the product does not have an anti-refresh mechanism, the user repeatedly refreshes the page due to manual error or other reasons, resulting in a large number of repeated SQL submissions."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"In the above four scenarios, the solution at the application layer puts the query results into Redis and periodically updates the cache or the user manually refreshes the cache. However, this solution has the following problems:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Inconsistent data"}),", unable to detect data updates, causing users to often see old data"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Low hit rate"}),", the entire query result is cached. If the data is written in real time, the cache fails frequently, the hit rate is low and the system load is heavy."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Additional Cost"}),", introducing external cache components will bring system complexity and increase additional costs."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"solution",children:"solution"}),"\n",(0,i.jsx)(t.p,{children:"This partition cache strategy can solve the above problems, giving priority to ensuring data consistency, and on this basis, refining the cache granularity and improving the hit rate, so it has the following characteristics:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Users do not need to worry about data consistency. Cache invalidation is controlled through versioning. The cached data is consistent with the data queried from BE."}),"\n",(0,i.jsx)(t.li,{children:"There are no additional components and costs, the cache results are stored in BE's memory, and users can adjust the cache memory size as needed"}),"\n",(0,i.jsx)(t.li,{children:"Implemented two caching strategies, SQLCache and PartitionCache, the latter has a finer cache granularity"}),"\n",(0,i.jsx)(t.li,{children:"Use consistent hashing to solve the problem of BE nodes going online and offline. The caching algorithm in BE is an improved LRU"}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"scenes-to-be-used",children:"scenes to be used"}),"\n",(0,i.jsx)(t.p,{children:"Currently, it supports two methods: SQL Cache and Partition Cache, and supports OlapTable internal table and Hive external table."}),"\n",(0,i.jsx)(t.p,{children:"SQL Cache: Only SQL statements that are completely consistent will hit the cache. For details, see: sql-cache-manual.md"}),"\n",(0,i.jsx)(t.p,{children:"Partition Cache: Multiple SQLs can hit the cache using the same table partition, so it has a higher hit rate than SQL Cache. For details, see: partition-cache-manual.md"}),"\n",(0,i.jsx)(t.h2,{id:"monitoring",children:"Monitoring"}),"\n",(0,i.jsx)(t.p,{children:"FE monitoring items:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-text",children:"query_table //The number of tables in Query\nquery_olap_table //The number of Olap tables in Query\ncache_mode_sql //Identify the number of Query whose cache mode is sql\ncache_hit_sql //The number of Query hits in Cache with mode sql\nquery_mode_partition //The number of queries that identify the cache mode as Partition\ncache_hit_partition //The number of Query hits through Partition\npartition_all //All partitions scanned in Query\npartition_hit //Number of partitions hit through Cache\n\nCache hit rate = (cache_hit_sql + cache_hit_partition) / query_olap_table\nPartition hit rate = partition_hit / partition_all\n"})}),"\n",(0,i.jsx)(t.p,{children:"BE monitoring items:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-text",children:"query_cache_memory_total_byte //Cache memory size\nquery_query_cache_sql_total_count //The number of SQL cached\nquery_cache_partition_total_count //Number of Cache partitions\n\nSQL average data size = cache_memory_total / cache_sql_total\nPartition average data size = cache_memory_total / cache_partition_total\n"})}),"\n",(0,i.jsx)(t.p,{children:"Other monitoring: You can view the CPU and memory indicators of the BE node, Query Percentile and other indicators in the Query statistics from Grafana, and adjust the Cache parameters to achieve business goals."}),"\n",(0,i.jsx)(t.h2,{id:"related-parameters",children:"Related parameters"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"cache_result_max_row_count"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"The maximum number of rows that the query result set can put into the cache. The default is 3000."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-text",children:"vim fe/conf/fe.conf\ncache_result_max_row_count=3000\n"})}),"\n",(0,i.jsxs)(t.ol,{start:"2",children:["\n",(0,i.jsx)(t.li,{children:"cache_result_max_data_size"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"The maximum data size of the query result set placed in the cache is 30M by default. It can be adjusted according to the actual situation, but it is recommended not to set it too large to avoid excessive memory usage. Result sets exceeding this size will not be cached."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-text",children:"vim fe/conf/fe.conf\ncache_result_max_data_size=31457280\n"})}),"\n",(0,i.jsxs)(t.ol,{start:"3",children:["\n",(0,i.jsx)(t.li,{children:"cache_last_version_interval_second"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"The minimum time interval between the latest version of the cached query partition and the current version. Only the query results of partitions that are larger than this interval and have not been updated will be cached. The default is 30, in seconds."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-text",children:"vim fe/conf/fe.conf\ncache_last_version_interval_second=30\n"})}),"\n",(0,i.jsxs)(t.ol,{start:"4",children:["\n",(0,i.jsx)(t.li,{children:"query_cache_max_size_mb and query_cache_elasticity_size"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"query_cache_max_size_mb is the upper memory limit of the cache, query_cache_elasticity_size is the memory size that the cache can stretch. When the total cache size on BE exceeds query_cache_max_size + cache_elasticity_size, it will start to be cleaned up and the memory will be controlled below query_cache_max_size."}),"\n",(0,i.jsx)(t.p,{children:"These two parameters can be set according to the number of BE nodes, node memory size, and cache hit rate. Calculation method: If 10,000 Queries are cached, each Query caches 1,000 rows, each row is 128 bytes, and is distributed on 10 BEs, then each BE requires about 128M memory (10,000 * 1,000 * 128/10)."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-text",children:"vim be/conf/be.conf\nquery_cache_max_size_mb=256\nquery_cache_elasticity_size_mb=128\n"})}),"\n",(0,i.jsxs)(t.ol,{start:"5",children:["\n",(0,i.jsx)(t.li,{children:"cache_max_partition_count"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Parameters unique to Partition Cache. The maximum number of BE partitions refers to the maximum number of partitions corresponding to each SQL. If it is partitioned by date, it can cache data for more than 2 years. If you want to keep the cache for a longer time, please set this parameter larger and modify the parameters at the same time. cache_result_max_row_count and cache_result_max_data_size."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-text",children:"vim be/conf/be.conf\ncache_max_partition_count=1024\n"})})]})}function d(e={}){let{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},250065:function(e,t,n){n.d(t,{Z:function(){return c},a:function(){return r}});var a=n(667294);let i={},s=a.createContext(i);function r(e){let t=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);
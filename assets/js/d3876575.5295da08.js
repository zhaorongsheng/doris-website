"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["854099"],{48060:function(e,t,s){s.r(t),s.d(t,{default:()=>h,frontMatter:()=>l,metadata:()=>n,assets:()=>o,toc:()=>c,contentTitle:()=>r});var n=JSON.parse('{"id":"data-operate/import/load-atomicity","title":"Loading Transaction and Atomicity","description":"\x3c!--","source":"@site/versioned_docs/version-2.0/data-operate/import/load-atomicity.md","sourceDirName":"data-operate/import","slug":"/data-operate/import/load-atomicity","permalink":"/docs/2.0/data-operate/import/load-atomicity","draft":false,"unlisted":false,"tags":[],"version":"2.0","frontMatter":{"title":"Loading Transaction and Atomicity","language":"en"},"sidebar":"docs","previous":{"title":"Migrating Data from Other OLAP","permalink":"/docs/2.0/data-operate/import/migrate-data-from-other-olap"},"next":{"title":"Converting Source Data","permalink":"/docs/2.0/data-operate/import/load-data-convert"}}'),a=s("785893"),i=s("250065");let l={title:"Loading Transaction and Atomicity",language:"en"},r=void 0,o={},c=[{value:"Use Cases",id:"use-cases",level:2},{value:"Basic Principles",id:"basic-principles",level:2},{value:"Label Mechanism",id:"label-mechanism",level:3},{value:"Quick Start",id:"quick-start",level:2},{value:"Insert Into",id:"insert-into",level:3},{value:"Stream Load",id:"stream-load",level:3},{value:"Broker Load",id:"broker-load",level:3},{value:"Best Practices",id:"best-practices",level:2}];function d(e){let t={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h2,{id:"use-cases",children:"Use Cases"}),"\n",(0,a.jsx)(t.p,{children:"All loading tasks in Doris are atomic, which means that a loading job either succeeds completely or fails completely. There won't be a situation where only part of the data is load successfully. Additionally, Doris ensures atomicity for loading multiple tables within the same loading task. Moreover, Doris ensures data loading without loss or duplication through the use of labels. For simple loading tasks, no additional configuration or operations are required. For materialized views associated with tables, atomicity and consistency with the base table are also guaranteed. Doris provides additional transaction control for the following scenarios:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:["If a user needs to combine multiple ",(0,a.jsx)(t.code,{children:"INSERT INTO"})," into a single transaction for the same target table, they can use the ",(0,a.jsx)(t.code,{children:"BEGIN"})," and ",(0,a.jsx)(t.code,{children:"COMMIT"})," commands."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"If a user needs to combine multiple stream load into a single transaction, they can use the two-phase commit mode of Stream Load."}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Atomicity of multi-table load with Broker Load."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"basic-principles",children:"Basic Principles"}),"\n",(0,a.jsx)(t.p,{children:"In a Doris loading task, the Backend (BE) submits the Tablet IDs of the successful writes to the Frontend (FE). FE determines the success of the load based on the number of successful tablet replicas. If loading is successful, the transaction is committed and the data load becomes visible. If it fails, the transaction is rolled back and the corresponding tablets are cleaned up."}),"\n",(0,a.jsx)(t.h3,{id:"label-mechanism",children:"Label Mechanism"}),"\n",(0,a.jsx)(t.p,{children:"Doris loading jobs can be assigned a label. This label is usually a user-defined string with certain business logic attributes."}),"\n",(0,a.jsx)(t.p,{children:"The main purpose of the label is to uniquely identify a loading task and ensure that the same label is loaded successfully only once."}),"\n",(0,a.jsx)(t.p,{children:"The label mechanism ensures that load data is not lost or duplicated. When combined with an upstream data source that guarantees At-Least-Once semantics, the label mechanism in Doris can ensure Exactly-Once semantics."}),"\n",(0,a.jsx)(t.p,{children:"Labels are unique within a database. The default retention period for labels is 3 days. After 3 days, completed labels are automatically cleaned up and can be reused."}),"\n",(0,a.jsx)(t.h2,{id:"quick-start",children:"Quick Start"}),"\n",(0,a.jsx)(t.h3,{id:"insert-into",children:"Insert Into"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"1. Create Table"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:'CREATE TABLE testdb.test_table(\n    user_id            BIGINT       NOT NULL COMMENT "User ID",\n    name               VARCHAR(20)  NOT NULL COMMENT "User Name",\n    age                INT                   COMMENT "User Age"\n)\nDUPLICATE KEY(user_id)\nDISTRIBUTED BY HASH(user_id) BUCKETS 10;\n'})}),"\n",(0,a.jsx)(t.p,{children:"Create a table with the same schema for the failed example:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:"CREATE TABLE testdb.test_table2 LIKE testdb.test_table;\n"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"2. Successful Load Example"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:'BEGIN;\n\n-- INSERT #1\nINSERT INTO testdb.test_table (user_id, name, age)\nVALUES (1, "Emily", 25),\n       (2, "Benjamin", 35),\n       (3, "Olivia", 28),\n       (4, "Alexander", 60),\n       (5, "Ava", 17);\n\n-- INSERT #2\nINSERT INTO testdb.test_table (user_id, name, age)\nVALUES (6, "William", 69),\n       (7, "Sophia", 32),\n       (8, "James", 64),\n       (9, "Emma", 37),\n       (10, "Liam", 64);\n\nCOMMIT;\n'})}),"\n",(0,a.jsxs)(t.p,{children:["Load result: The loading task starts with the ",(0,a.jsx)(t.code,{children:"PREPARE"})," status and becomes ",(0,a.jsx)(t.code,{children:"VISIBLE"})," only after the COMMIT."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-JSON",children:"// BEGIN\nQuery OK, 0 rows affected (0.001 sec)\n{'label':'txn_insert_2aeac5519bd549a1-a72fe4001c56e10c', 'status':'PREPARE', 'txnId':''}\n\n// INSERT #1\nQuery OK, 5 rows affected (0.017 sec)\n{'label':'txn_insert_2aeac5519bd549a1-a72fe4001c56e10c', 'status':'PREPARE', 'txnId':'10060'}\n\n// INSERT #2\nQuery OK, 5 rows affected (0.007 sec)\n{'label':'txn_insert_2aeac5519bd549a1-a72fe4001c56e10c', 'status':'PREPARE', 'txnId':'10060'}\n\n// COMMIT\nQuery OK, 0 rows affected (1.013 sec)\n{'label':'txn_insert_2aeac5519bd549a1-a72fe4001c56e10c', 'status':'VISIBLE', 'txnId':'10060'}\n"})}),"\n",(0,a.jsx)(t.p,{children:"Verify the data:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-JSON",children:"MySQL [testdb]> SELECT * FROM testdb.test_table2;\nEmpty set (0.019 sec)\n"})}),"\n",(0,a.jsx)(t.h3,{id:"stream-load",children:"Stream Load"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsxs)(t.strong,{children:["1. Enable two-phase commit by setting ",(0,a.jsx)(t.code,{children:"two_phase_commit:true"})," in the HTTP Header."]})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-shell",children:'curl --location-trusted -u user:passwd -H "two_phase_commit:true" -T test.txt http://fe_host:http_port/api/{db}/{table}/_stream_load\n{\n    "TxnId": 18036,\n    "Label": "55c8ffc9-1c40-4d51-b75e-f2265b3602ef",\n    "TwoPhaseCommit": "true",\n    "Status": "Success",\n    "Message": "OK",\n    "NumberTotalRows": 100,\n    "NumberLoadedRows": 100,\n    "NumberFilteredRows": 0,\n    "NumberUnselectedRows": 0,\n    "LoadBytes": 1031,\n    "LoadTimeMs": 77,\n    "BeginTxnTimeMs": 1,\n    "StreamLoadPutTimeMs": 1,\n    "ReadDataTimeMs": 0,\n    "WriteDataTimeMs": 58,\n    "CommitAndPublishTimeMs": 0\n}\n'})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"2. Trigger the commit operation for a transaction (can be sent to FE or BE)."})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Specify the transaction using the Transaction ID:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-shell",children:'curl -X PUT --location-trusted -u user:passwd -H "txn_id:18036" -H "txn_operation:commit" http://fe_host:http_port/api/{db}/{table}/stream_load2pc\n{\n    "status": "Success",\n    "msg": "transaction [18036] commit successfully."\n}\n'})}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Specify the transaction using the label:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-shell",children:'curl -X PUT --location-trusted -u user:passwd -H "label:55c8ffc9-1c40-4d51-b75e-f2265b3602ef" -H "txn_operation:commit"  http://fe_host:http_port/api/{db}/{table}/_stream_load_2pc\n{\n    "status": "Success",\n    "msg": "label [55c8ffc9-1c40-4d51-b75e-f2265b3602ef] commit successfully."\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"3. Trigger the abort operation for a transaction (can be sent to FE or BE)."})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Specify the transaction using the Transaction ID:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-shell",children:'curl -X PUT --location-trusted -u user:passwd -H "txn_id:18037" -H "txn_operation:abort"  http://fe_host:http_port/api/{db}/{table}/stream_load2pc\n{\n    "status": "Success",\n    "msg": "transaction [18037] abort successfully."\n}\n'})}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Specify the transaction using the label:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-shell",children:'curl -X PUT --location-trusted -u user:passwd -H "label:55c8ffc9-1c40-4d51-b75e-f2265b3602ef" -H "txn_operation:abort"  http://fe_host:http_port/api/{db}/{table}/stream_load2pc\n{\n    "status": "Success",\n    "msg": "label [55c8ffc9-1c40-4d51-b75e-f2265b3602ef] abort successfully."\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"broker-load",children:"Broker Load"}),"\n",(0,a.jsx)(t.p,{children:"All Broker Load tasks are atomic and ensure atomicity even when loading multiple tables within the same task. The Label mechanism can be used to ensure data load without loss or duplication."}),"\n",(0,a.jsx)(t.p,{children:"The following example demonstrates loading data from HDFS by using wildcard patterns to match two sets of files and load them into two different tables."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:'LOAD LABEL example_db.label2\n(\n    DATA INFILE("hdfs://hdfs_host:hdfs_port/input/file-10*")\n    INTO TABLE `my_table1`\n    PARTITION (p1)\n    COLUMNS TERMINATED BY ","\n    (k1, tmp_k2, tmp_k3)\n    SET (\n        k2 = tmp_k2 + 1,\n        k3 = tmp_k3 + 1\n    )\n    DATA INFILE("hdfs://hdfs_host:hdfs_port/input/file-20*")\n    INTO TABLE `my_table2`\n    COLUMNS TERMINATED BY ","\n    (k1, k2, k3)\n)\nWITH BROKER hdfs\n(\n    "username"="hdfs_user",\n    "password"="hdfs_password"\n);\n'})}),"\n",(0,a.jsxs)(t.p,{children:["The wildcard pattern is used to match and load two sets of files, ",(0,a.jsx)(t.code,{children:"file-10*"})," and ",(0,a.jsx)(t.code,{children:"file-20*"}),", into ",(0,a.jsx)(t.code,{children:"my_table1"})," and ",(0,a.jsx)(t.code,{children:"my_table2"})," respectively. In the case of ",(0,a.jsx)(t.code,{children:"my_table1"}),", the load is specified to the ",(0,a.jsx)(t.code,{children:"p1"})," partition, and the values of thesecond and third columns in the source file are incremented by 1 before being loaded."]}),"\n",(0,a.jsx)(t.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsxs)(t.p,{children:["Labels are typically set in the format of ",(0,a.jsx)(t.code,{children:"business_logic+time"}),", such as ",(0,a.jsx)(t.code,{children:"my_business1_20220330_125000"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["This label is commonly used to represent a batch of data generated by the business logic ",(0,a.jsx)(t.code,{children:"my_business1"})," at ",(0,a.jsx)(t.code,{children:"2022-03-30 12:50:00"}),". By setting this label, the business can query the loading task status using the label to determine whether the data batch at that specific time has been successfully load. If the load fails, the label can be used to retry the load."]}),"\n",(0,a.jsx)(t.p,{children:"INSERT INTO supports loading the result of a Doris query into another table. INSERT INTO is a synchronous load method that returns the load result after execution. The success or failure of the load can be determined based on the response. INSERT INTO ensures the atomicity of the loading task, either all succeed or all fail load."})]})}function h(e={}){let{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},250065:function(e,t,s){s.d(t,{Z:function(){return r},a:function(){return l}});var n=s(667294);let a={},i=n.createContext(a);function l(e){let t=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);
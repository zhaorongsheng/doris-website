"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["482201"],{77505:function(e,t,n){n.r(t),n.d(t,{default:()=>h,frontMatter:()=>r,metadata:()=>a,assets:()=>o,toc:()=>l,contentTitle:()=>c});var a=JSON.parse('{"id":"compute-storage-decoupled/file-cache","title":"File Cache","description":"\x3c!--","source":"@site/docs/compute-storage-decoupled/file-cache.md","sourceDirName":"compute-storage-decoupled","slug":"/compute-storage-decoupled/file-cache","permalink":"/docs/dev/compute-storage-decoupled/file-cache","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"File Cache","language":"en"},"sidebar":"docs","previous":{"title":"Managing Compute Groups","permalink":"/docs/dev/compute-storage-decoupled/managing-compute-cluster"},"next":{"title":"Upgrade","permalink":"/docs/dev/compute-storage-decoupled/upgrade"}}'),i=n("785893"),s=n("250065");let r={title:"File Cache",language:"en"},c=void 0,o={},l=[{value:"Multi-Queue LRU",id:"multi-queue-lru",level:2},{value:"LRU",id:"lru",level:3},{value:"TTL (Time-To-Live)",id:"ttl-time-to-live",level:3},{value:"Multi-Queue",id:"multi-queue",level:3},{value:"Eviction",id:"eviction",level:3},{value:"Cache Warming",id:"cache-warming",level:2},{value:"Compute Group Scaling",id:"compute-group-scaling",level:2},{value:"Cache Observation",id:"cache-observation",level:2},{value:"Hotspot Information",id:"hotspot-information",level:3},{value:"Viewing the Most Frequently Accessed Tables Across All Compute Groups",id:"viewing-the-most-frequently-accessed-tables-across-all-compute-groups",level:4},{value:"Viewing the Most Frequently Accessed Tables Under a Specific Compute Group",id:"viewing-the-most-frequently-accessed-tables-under-a-specific-compute-group",level:4},{value:"Viewing the Most Frequently Accessed Partitions for a Specific Compute Group and Table",id:"viewing-the-most-frequently-accessed-partitions-for-a-specific-compute-group-and-table",level:4},{value:"Cache Space and Hit Rate",id:"cache-space-and-hit-rate",level:3},{value:"SQL Profile",id:"sql-profile",level:3},{value:"Usage",id:"usage",level:2},{value:"Setting TTL Strategy",id:"setting-ttl-strategy",level:3},{value:"Cache Warming",id:"cache-warming-1",level:3},{value:"Practical Case",id:"practical-case",level:2}];function d(e){let t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"In a decoupled architecture, data is stored in remote storage. The Doris database accelerates data access by utilizing a cache on local disks and employs an advanced multi-queue LRU (Least Recently Used) strategy to efficiently manage cache space. This strategy particularly optimizes the access paths for indexes and metadata, aiming to maximize the caching of frequently accessed user data. For multi-compute group (Compute Group) scenarios, Doris also provides a cache warming feature to quickly load specific data (such as tables or partitions) into the cache when a new compute group is established, thereby enhancing query performance."}),"\n",(0,i.jsx)(t.h2,{id:"multi-queue-lru",children:"Multi-Queue LRU"}),"\n",(0,i.jsx)(t.h3,{id:"lru",children:"LRU"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"LRU manages the cache by maintaining a data access queue. When data is accessed, it is moved to the front of the queue. Newly added data to the cache is also placed at the front of the queue to prevent it from being evicted too early. When the cache space reaches its limit, data at the tail of the queue will be removed first."}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"ttl-time-to-live",children:"TTL (Time-To-Live)"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"The TTL strategy ensures that newly imported data remains in the cache for a certain period without being evicted. During this time, the data has the highest priority, and all TTL data are treated equally. When cache space is insufficient, the system will prioritize evicting data from other queues to ensure that TTL data can be written to the cache."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Application scenarios: The TTL strategy is particularly suitable for small-scale data tables that require local persistence. For resident tables, a longer TTL value can be set to protect their data; for dynamically partitioned tables, the TTL value can be set according to the active time of Hot Partitions."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Note: Currently, the system does not support directly viewing the proportion of TTL data in the cache."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"multi-queue",children:"Multi-Queue"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Doris adopts a multi-queue strategy based on LRU, categorizing data into four types based on TTL attributes and data properties, and placing them in TTL queues, Index queues, NormalData queues, and Disposable queues. Data with a TTL attribute is placed in the TTL queue, index data without a TTL attribute is placed in the Index queue, normal data without a TTL attribute is placed in the NormalData queue, and temporary data is placed in the Disposable queue."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"During data read and write processes, Doris selects the queues to fill and read from to maximize cache utilization. The specific mechanism is as follows:"}),"\n"]}),"\n"]}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Operation"}),(0,i.jsx)(t.th,{children:"Queue Filled on Miss"}),(0,i.jsx)(t.th,{children:"Queue Filled on Write"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Import"}),(0,i.jsx)(t.td,{children:"TTL / Index / NormalData"}),(0,i.jsx)(t.td,{children:"TTL / Index / NormalData"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Query"}),(0,i.jsx)(t.td,{children:"TTL / Index / NormalData"}),(0,i.jsx)(t.td,{children:"N/A"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Schema Change"}),(0,i.jsx)(t.td,{children:"Disposable"}),(0,i.jsx)(t.td,{children:"TTL / Index / NormalData"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Compaction"}),(0,i.jsx)(t.td,{children:"Disposable"}),(0,i.jsx)(t.td,{children:"TTL / Index / NormalData"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Warm-up"}),(0,i.jsx)(t.td,{children:"N/A"}),(0,i.jsx)(t.td,{children:"TTL / Index / NormalData"})]})]})]}),"\n",(0,i.jsx)(t.h3,{id:"eviction",children:"Eviction"}),"\n",(0,i.jsxs)(t.p,{children:["All types of caches share the total cache space, and proportions can be allocated based on their importance. These proportions can be set in the ",(0,i.jsx)(t.code,{children:"be"})," configuration file using ",(0,i.jsx)(t.code,{children:"file_cache_path"}),", with the default being: TTL: Normal: Index: Disposable = 50%: 30%: 10%: 10%."]}),"\n",(0,i.jsx)(t.p,{children:"These proportions are not rigid limits; Doris dynamically adjusts them to make full use of space. E.g., if users do not utilize TTL cache, other types can exceed the preset proportion and use the space originally allocated for TTL."}),"\n",(0,i.jsx)(t.p,{children:"Cache eviction is triggered by two conditions: garbage collection or insufficient cache space. When users delete data or when compaction tasks end, expired cache data is asynchronously evicted. When there is not enough space to write to the cache, eviction follows the order of Disposable, Normal Data, Index, and TTL. For instance, if there is not enough space to write Normal Data, Doris will sequentially evict some Disposable, Index, and TTL data in LRU order. Note that we do not evict all data of the target type before moving on to the next type; instead, we retain at least the aforementioned proportions to ensure other types can function properly. If this process does not free up enough space, LRU eviction for the type itself will be triggered. E.g., if not enough space can be freed from other types when writing Normal Data, Normal Data will then evict its own data in LRU order."}),"\n",(0,i.jsx)(t.p,{children:"Specifically, for the TTL queue with expiration times, when data expires, it is moved to the Normal Data queue and participates in eviction as Normal Data."}),"\n",(0,i.jsx)(t.h2,{id:"cache-warming",children:"Cache Warming"}),"\n",(0,i.jsx)(t.p,{children:"In a decoupled mode, Doris supports multi-compute group deployment, where compute groups share data but do not share cache. When a new compute group is created, its cache is empty, which may affect query performance. Therefore, Doris provides a cache warming feature that allows users to actively pull data from remote storage to local cache. This feature supports the following three modes:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Inter-Compute Group Warming"}),": Warm the cache data of Compute Group A to Compute Group B. Doris periodically collects hotspot information of tables/partitions accessed in each compute group over a period and selectively warms certain tables/partitions based on this information."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Table Data Warming"}),": Specify to warm the data of Table A to the new compute group."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Partition Data Warming"}),": Specify to warm the data of partition ",(0,i.jsx)(t.code,{children:"p1"})," of Table A to the new compute group."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"compute-group-scaling",children:"Compute Group Scaling"}),"\n",(0,i.jsx)(t.p,{children:"When scaling Compute Groups, to avoid cache fluctuations, Doris will first remap the affected tablets and warm the data."}),"\n",(0,i.jsx)(t.h2,{id:"cache-observation",children:"Cache Observation"}),"\n",(0,i.jsx)(t.h3,{id:"hotspot-information",children:"Hotspot Information"}),"\n",(0,i.jsx)(t.p,{children:"Doris collects cache hotspot information for each compute group every 10 minutes and stores it in an internal system table. You can view this hotspot information using query statements. Users can better plan their cache usage based on this information."}),"\n",(0,i.jsx)(t.admonition,{title:"Note",type:"info",children:(0,i.jsxs)(t.p,{children:["Before version 3.0.4, the ",(0,i.jsx)(t.code,{children:"SHOW CACHE HOTSPOT"})," statement could be used to query cache hotspot information statistics. Starting from version 3.0.4, the ",(0,i.jsx)(t.code,{children:"SHOW CACHE HOTSPOT"})," statement is no longer supported for querying cache hotspot information statistics. Please directly query the system table ",(0,i.jsx)(t.code,{children:"__internal_schema.cloud_cache_hotspot"}),"."]})}),"\n",(0,i.jsx)(t.p,{children:"Users typically focus on cache usage information at two levels: compute groups and database tables. The following provides some commonly used query statements and examples."}),"\n",(0,i.jsx)(t.h4,{id:"viewing-the-most-frequently-accessed-tables-across-all-compute-groups",children:"Viewing the Most Frequently Accessed Tables Across All Compute Groups"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-sql",children:'-- Equivalent to SHOW CACHE HOTSPOT "/" before version 3.0.4\nWITH t1 AS (\n  SELECT\n    cluster_id,\n    cluster_name,\n    table_id,\n    table_name,\n    insert_day,\n    SUM(query_per_day) AS query_per_day_total,\n    SUM(query_per_week) AS query_per_week_total\n  FROM __internal_schema.cloud_cache_hotspot\n  GROUP BY cluster_id, cluster_name, table_id, table_name, insert_day\n)\nSELECT\n  cluster_id AS ComputeGroupId,\n  cluster_name AS ComputeGroupName,\n  table_id AS TableId,\n  table_name AS TableName\nFROM (\n  SELECT\n    ROW_NUMBER() OVER (\n      PARTITION BY cluster_id\n      ORDER BY insert_day DESC, query_per_day_total DESC, query_per_week_total DESC\n    ) AS dr2,\n    *\n  FROM t1\n) t2\nWHERE dr2 = 1;\n'})}),"\n",(0,i.jsx)(t.h4,{id:"viewing-the-most-frequently-accessed-tables-under-a-specific-compute-group",children:"Viewing the Most Frequently Accessed Tables Under a Specific Compute Group"}),"\n",(0,i.jsxs)(t.p,{children:["Viewing the most frequently accessed tables under compute group ",(0,i.jsx)(t.code,{children:"compute_group_name0"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Note: Replace the condition ",(0,i.jsx)(t.code,{children:'cluster_name = "compute_group_name0"'})," with the actual compute group name."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-sql",children:'-- Equivalent to SHOW CACHE HOTSPOT \'/compute_group_name0\' before version 3.0.4\nWITH t1 AS (\n  SELECT\n    cluster_id,\n    cluster_name,\n    table_id,\n    table_name,\n    insert_day,\n    SUM(query_per_day) AS query_per_day_total,\n    SUM(query_per_week) AS query_per_week_total\n  FROM __internal_schema.cloud_cache_hotspot\n  WHERE cluster_name = "compute_group_name0" -- Replace with the actual compute group name, e.g., "default_compute_group"\n  GROUP BY cluster_id, cluster_name, table_id, table_name, insert_day\n)\nSELECT\n  cluster_id AS ComputeGroupId,\n  cluster_name AS ComputeGroupName,\n  table_id AS TableId,\n  table_name AS TableName\nFROM (\n  SELECT\n    ROW_NUMBER() OVER (\n      PARTITION BY cluster_id\n      ORDER BY insert_day DESC, query_per_day_total DESC, query_per_week_total DESC\n    ) AS dr2,\n    *\n  FROM t1\n) t2\nWHERE dr2 = 1;\n'})}),"\n",(0,i.jsx)(t.h4,{id:"viewing-the-most-frequently-accessed-partitions-for-a-specific-compute-group-and-table",children:"Viewing the Most Frequently Accessed Partitions for a Specific Compute Group and Table"}),"\n",(0,i.jsxs)(t.p,{children:["Viewing the most frequently accessed partitions for table ",(0,i.jsx)(t.code,{children:"regression_test_cloud_load_copy_into_tpch_sf1_p1.customer"})," under compute group ",(0,i.jsx)(t.code,{children:"compute_group_name0"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Note: Replace the conditions ",(0,i.jsx)(t.code,{children:'cluster_name = "compute_group_name0"'})," and ",(0,i.jsx)(t.code,{children:'table_name = "regression_test_cloud_load_copy_into_tpch_sf1_p1.customer"'})," with the actual compute group name and database table name."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-sql",children:'-- Equivalent to SHOW CACHE HOTSPOT \'/compute_group_name0/regression_test_cloud_load_copy_into_tpch_sf1_p1.customer\' before version 3.0.4\nSELECT\n  partition_id AS PartitionId,\n  partition_name AS PartitionName\nFROM __internal_schema.cloud_cache_hotspot\nWHERE\n  cluster_name = "compute_group_name0" -- Replace with the actual compute group name, e.g., "default_compute_group"\n  AND table_name = "regression_test_cloud_load_copy_into_tpch_sf1_p1.customer" -- Replace with the actual database table name, e.g., "db1.t1"\nGROUP BY\n  cluster_id,\n  cluster_name,\n  table_id,\n  table_name,\n  partition_id,\n  partition_name;\n'})}),"\n",(0,i.jsx)(t.h3,{id:"cache-space-and-hit-rate",children:"Cache Space and Hit Rate"}),"\n",(0,i.jsxs)(t.p,{children:["Doris BE nodes can obtain cache statistics by using ",(0,i.jsx)(t.code,{children:"curl {be_ip}:{brpc_port}/vars"})," (where brpc_port defaults to 8060), and the names of the metrics start with the disk path."]}),"\n",(0,i.jsxs)(t.p,{children:['In the above example, the metric prefix for File Cache is the path, for example, the prefix "',(0,i.jsx)(t.em,{children:"mnt_disk1_gavinchou_debug_doris_cloud_be0_storage_file_cache"}),'" indicates "/mnt/disk1/gavinchou/debug/doris-cloud/be0_storage_file_cache/"\nThe part after the prefix is the statistical metric, for example, "file_cache_cache_size" indicates that the current size of the File Cache at this path is 26111 bytes.']}),"\n",(0,i.jsx)(t.p,{children:"The following table lists the meanings of all metrics (all size units are in bytes):"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Metric Name (excluding path prefix)"}),(0,i.jsx)(t.th,{children:"Meaning"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"file_cache_cache_size"}),(0,i.jsx)(t.td,{children:"Current total size of the File Cache"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"file_cache_disposable_queue_cache_size"}),(0,i.jsx)(t.td,{children:"Current size of the disposable queue"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"file_cache_disposable_queue_element_count"}),(0,i.jsx)(t.td,{children:"Current number of elements in the disposable queue"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"file_cache_disposable_queue_evict_size"}),(0,i.jsx)(t.td,{children:"Total amount of data evicted from the disposable queue since startup"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"file_cache_index_queue_cache_size"}),(0,i.jsx)(t.td,{children:"Current size of the index queue"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"file_cache_index_queue_element_count"}),(0,i.jsx)(t.td,{children:"Current number of elements in the index queue"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"file_cache_index_queue_evict_size"}),(0,i.jsx)(t.td,{children:"Total amount of data evicted from the index queue since startup"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"file_cache_normal_queue_cache_size"}),(0,i.jsx)(t.td,{children:"Current size of the normal queue"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"file_cache_normal_queue_element_count"}),(0,i.jsx)(t.td,{children:"Current number of elements in the normal queue"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"file_cache_normal_queue_evict_size"}),(0,i.jsx)(t.td,{children:"Total amount of data evicted from the normal queue since startup"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"file_cache_total_evict_size"}),(0,i.jsx)(t.td,{children:"Total amount of data evicted from the entire File Cache since startup"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"file_cache_ttl_cache_evict_size"}),(0,i.jsx)(t.td,{children:"Total amount of data evicted from the TTL queue since startup"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"file_cache_ttl_cache_lru_queue_element_count"}),(0,i.jsx)(t.td,{children:"Current number of elements in the TTL queue"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"file_cache_ttl_cache_size"}),(0,i.jsx)(t.td,{children:"Current size of the TTL queue"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"file_cache_evict_by_heat_[A]_to_[B]"}),(0,i.jsx)(t.td,{children:"Data from cache type A evicted due to cache type B (time-based expiration)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"file_cache_evict_by_size_[A]_to_[B]"}),(0,i.jsx)(t.td,{children:"Data from cache type A evicted due to cache type B (space-based expiration)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"file_cache_evict_by_self_lru_[A]"}),(0,i.jsx)(t.td,{children:"Data from cache type A evicted by its own LRU policy for new data"})]})]})]}),"\n",(0,i.jsx)(t.h3,{id:"sql-profile",children:"SQL Profile"}),"\n",(0,i.jsx)(t.p,{children:"Cache-related metrics in the SQL profile are found under SegmentIterator, including:"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Metric Name"}),(0,i.jsx)(t.th,{children:"Meaning"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"BytesScannedFromCache"}),(0,i.jsx)(t.td,{children:"Amount of data read from the File Cache"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"BytesScannedFromRemote"}),(0,i.jsx)(t.td,{children:"Amount of data read from remote storage"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"BytesWriteIntoCache"}),(0,i.jsx)(t.td,{children:"Amount of data written into the File Cache"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"LocalIOUseTimer"}),(0,i.jsx)(t.td,{children:"Time taken to read from the File Cache"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"NumLocalIOTotal"}),(0,i.jsx)(t.td,{children:"Number of times the File Cache was read"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"NumRemoteIOTotal"}),(0,i.jsx)(t.td,{children:"Number of times remote storage was read"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"NumSkipCacheIOTotal"}),(0,i.jsx)(t.td,{children:"Number of times data read from remote storage did not enter the File Cache"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"RemoteIOUseTimer"}),(0,i.jsx)(t.td,{children:"Time taken to read from remote storage"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"WriteCacheIOUseTimer"}),(0,i.jsx)(t.td,{children:"Time taken to write to the File Cache"})]})]})]}),"\n",(0,i.jsxs)(t.p,{children:["You can view query performance analysis through ",(0,i.jsx)(t.a,{href:"../query-acceleration/performance-tuning-overview/analysis-tools#doris-profile",children:"Query Performance Analysis"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"usage",children:"Usage"}),"\n",(0,i.jsx)(t.h3,{id:"setting-ttl-strategy",children:"Setting TTL Strategy"}),"\n",(0,i.jsx)(t.p,{children:"When creating a table, set the corresponding PROPERTY to use the TTL strategy for caching that table's data."}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"file_cache_ttl_seconds"}),": The expected time for newly imported data to remain in the cache, in seconds."]}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-shell",children:'CREATE TABLE IF NOT EXISTS customer (\n  C_CUSTKEY     INTEGER NOT NULL,\n  C_NAME        VARCHAR(25) NOT NULL,\n  C_ADDRESS     VARCHAR(40) NOT NULL,\n  C_NATIONKEY   INTEGER NOT NULL,\n  C_PHONE       CHAR(15) NOT NULL,\n  C_ACCTBAL     DECIMAL(15,2)   NOT NULL,\n  C_MKTSEGMENT  CHAR(10) NOT NULL,\n  C_COMMENT     VARCHAR(117) NOT NULL\n)\nDUPLICATE KEY(C_CUSTKEY, C_NAME)\nDISTRIBUTED BY HASH(C_CUSTKEY) BUCKETS 32\nPROPERTIES(\n    "file_cache_ttl_seconds"="300"\n)\n'})}),"\n",(0,i.jsx)(t.p,{children:"In the above table, all newly imported data will be retained in the cache for 300 seconds. The system currently supports modifying the TTL time of the table, and users can extend or shorten the TTL time based on actual needs."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-SQL",children:'ALTER TABLE customer set ("file_cache_ttl_seconds"="3000");\n'})}),"\n",(0,i.jsxs)(t.admonition,{title:"Note",type:"info",children:[(0,i.jsx)(t.p,{children:"The modified TTL value will not take effect immediately and will have a certain delay."}),(0,i.jsx)(t.p,{children:"If no TTL is set when creating the table, users can also modify the table's TTL attribute by executing the ALTER statement."})]}),"\n",(0,i.jsx)(t.h3,{id:"cache-warming-1",children:"Cache Warming"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Inter-Compute Group Warming. Warm the cache data of ",(0,i.jsx)(t.code,{children:"compute_group_name0"})," to ",(0,i.jsx)(t.code,{children:"compute_group_name1"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["When executing the following SQL, the ",(0,i.jsx)(t.code,{children:"compute_group_name1"})," compute group will obtain the access information of the ",(0,i.jsx)(t.code,{children:"compute_group_name0"})," compute group to restore the cache as closely as possible to that of ",(0,i.jsx)(t.code,{children:"compute_group_name0"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-sql",children:"WARM UP COMPUTE GROUP compute_group_name1 WITH COMPUTE GROUP compute_group_name0\n"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Table Data Warming. Warm the data of the table ",(0,i.jsx)(t.code,{children:"customer"})," to ",(0,i.jsx)(t.code,{children:"compute_group_name1"}),". Executing the following SQL will pull all data of that table from remote storage to local."]}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-sql",children:"WARM UP COMPUTE GROUP compute_group_name1 WITH TABLE customer\n"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Partition Data Warming. Warm the data of partition ",(0,i.jsx)(t.code,{children:"p1"})," of the table ",(0,i.jsx)(t.code,{children:"customer"})," to ",(0,i.jsx)(t.code,{children:"compute_group_name1"}),". Executing the following SQL will pull all data of that partition from remote storage to local."]}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-sql",children:"WARM UP COMPUTE GROUP compute_group_name1 with TABLE customer PARTITION p1\n"})}),"\n",(0,i.jsx)(t.p,{children:"The above three cache warming SQL statements will return a JobID result. For example:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-sql",children:"WARM UP COMPUTE GROUP cloud_warm_up WITH TABLE test_warm_up;\n"})}),"\n",(0,i.jsx)(t.p,{children:"You can then check the cache warming progress with the following SQL."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-sql",children:"SHOW WARM UP JOB WHERE ID = 13418; \n"})}),"\n",(0,i.jsxs)(t.p,{children:["You can determine the current task progress based on ",(0,i.jsx)(t.code,{children:"FinishBatch"})," and ",(0,i.jsx)(t.code,{children:"AllBatch"}),", with each Batch's data size being approximately 10GB. Currently, only one warming job is supported to run at a time within a compute group. Users can stop an ongoing warming job."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-sql",children:"CANCEL WARM UP JOB WHERE id = 13418;\n"})}),"\n",(0,i.jsx)(t.h2,{id:"practical-case",children:"Practical Case"}),"\n",(0,i.jsxs)(t.p,{children:["A user has a series of data tables with a total data volume exceeding 3TB, while the available cache capacity is only 1.2TB. Among them, there are two tables with high access frequency: one is a dimension table of size 200MB (",(0,i.jsx)(t.code,{children:"dimension_table"}),"), and the other is a fact table of size 100GB (",(0,i.jsx)(t.code,{children:"fact_table"}),"), which has new data imported daily and requires T+1 query operations. Additionally, other large tables have low access frequency."]}),"\n",(0,i.jsx)(t.p,{children:"Under the LRU caching strategy, if large table data is queried, it may replace the small table data that needs to remain in the cache, causing performance fluctuations. To solve this problem, the user adopts a TTL caching strategy, setting the TTL times for the two tables to 1 year and 1 day, respectively."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-shell",children:'ALTER TABLE dimension_table set ("file_cache_ttl_seconds"="31536000");\n\nALTER TABLE fact_table set ("file_cache_ttl_seconds"="86400");\n'})}),"\n",(0,i.jsx)(t.p,{children:"For the dimension table, due to its smaller size and less variability, the user sets a TTL time of 1 year to ensure that its data can be accessed quickly within a year; for the fact table, the user needs to perform a table backup daily and then conduct a full import, so the TTL time is set to 1 day."})]})}function h(e={}){let{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},250065:function(e,t,n){n.d(t,{Z:function(){return c},a:function(){return r}});var a=n(667294);let i={},s=a.createContext(i);function r(e){let t=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);
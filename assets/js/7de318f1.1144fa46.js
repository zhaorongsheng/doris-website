"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["412430"],{330767:function(e,n,t){t.r(n),t.d(n,{default:()=>u,frontMatter:()=>s,metadata:()=>i,assets:()=>c,toc:()=>d,contentTitle:()=>r});var i=JSON.parse('{"id":"query/query-data/window-function","title":"Window Function","description":"\x3c!--","source":"@site/versioned_docs/version-2.0/query/query-data/window-function.md","sourceDirName":"query/query-data","slug":"/query/query-data/window-function","permalink":"/docs/2.0/query/query-data/window-function","draft":false,"unlisted":false,"tags":[],"version":"2.0","frontMatter":{"title":"Window Function","language":"en"},"sidebar":"docs","previous":{"title":"Column to Row (Lateral View)","permalink":"/docs/2.0/query/query-data/lateral-view"},"next":{"title":"Encrption and Masking Function ","permalink":"/docs/2.0/query/query-data/encryption-function"}}'),o=t("785893"),a=t("250065");let s={title:"Window Function",language:"en"},r=void 0,c={},d=[{value:"Window function",id:"window-function",level:2},{value:"Function",id:"function",level:3},{value:"PARTITION BY clause",id:"partition-by-clause",level:3},{value:"ORDER BY clause",id:"order-by-clause",level:3},{value:"Window clause",id:"window-clause",level:4},{value:"Example",id:"example",level:3},{value:"See more",id:"see-more",level:3}];function l(e){let n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",p:"p",pre:"pre",...(0,a.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"window-function",children:"Window function"}),"\n",(0,o.jsxs)(n.p,{children:["Window functions are a special type of built-in functions in databases. Similar to aggregate functions, window functions perform calculations on multiple input rows to obtain a single data value. However, the difference lies in the fact that window functions process the input data within a specific window, rather than grouping and calculating based on the ",(0,o.jsx)(n.code,{children:"GROUP BY"})," clause. The data within each window can be sorted and grouped using the ",(0,o.jsx)(n.code,{children:"OVER()"})," clause. Window functions calculate a separate value for each row of the result set, rather than a single value for each ",(0,o.jsx)(n.code,{children:"GROUP BY"}),". This flexible approach allows users to add additional columns in the ",(0,o.jsx)(n.code,{children:"SELECT"})," clause, providing more opportunities to reorganize and filter the result set. Window functions can only appear in the select list and the outermost ",(0,o.jsx)(n.code,{children:"ORDER BY"})," clause. During the query process, window functions take effect at the end, meaning they are executed after operations such as ",(0,o.jsx)(n.code,{children:"JOIN"}),", ",(0,o.jsx)(n.code,{children:"WHERE"}),", and ",(0,o.jsx)(n.code,{children:"GROUP BY"}),". Window functions are often used in finance and scientific computing to analyze trends, calculate outliers, and perform bucket analysis on large amounts of data."]}),"\n",(0,o.jsx)(n.p,{children:"The syntax of window functions as follows:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"function(args) OVER(partition_by_clause order_by_clause [window_clause])    \npartition_by_clause ::= PARTITION BY expr [, expr ...]    \norder_by_clause ::= ORDER BY expr [ASC | DESC] [, expr [ASC | DESC] ...]\n"})}),"\n",(0,o.jsx)(n.h3,{id:"function",children:"Function"}),"\n",(0,o.jsx)(n.p,{children:"The currently supported functions include AVG(), COUNT(), DENSE_RANK(), FIRST_VALUE(), LAG(), LAST_VALUE(), LEAD(), MAX(), MIN(), RANK(), ROW_NUMBER(), SUM() and all aggregate functions."}),"\n",(0,o.jsx)(n.h3,{id:"partition-by-clause",children:"PARTITION BY clause"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"Partition By"})," clause is similar to ",(0,o.jsx)(n.code,{children:"Group By"}),". It groups input rows based on the specified one or more columns, where rows with the same values are placed in the same group."]}),"\n",(0,o.jsx)(n.h3,{id:"order-by-clause",children:"ORDER BY clause"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"Order By"})," clause within a window function behaves similarly to the outer-level ",(0,o.jsx)(n.code,{children:"Order By"}),". It defines the arrangement of input rows, and when ",(0,o.jsx)(n.code,{children:"Partition By"})," is specified, the ",(0,o.jsx)(n.code,{children:"Order By"})," determines the order within each partition. The only difference from the outer ",(0,o.jsx)(n.code,{children:"Order By"})," is that within the ",(0,o.jsx)(n.code,{children:"OVER"})," clause, using ",(0,o.jsx)(n.code,{children:"Order By n"})," (where n is a positive integer) effectively does nothing, whereas in the outer context, ",(0,o.jsx)(n.code,{children:"Order By n"})," signifies sorting based on the nth column."]}),"\n",(0,o.jsxs)(n.p,{children:["This example demonstrates adding an ",(0,o.jsx)(n.code,{children:"id"})," column to the select list, where its values are 1, 2, 3, and so on, sorted according to the ",(0,o.jsx)(n.code,{children:"date_and_time"})," column in the ",(0,o.jsx)(n.code,{children:"events"})," table."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"SELECT   \nrow_number() OVER (ORDER BY date_and_time) AS id,   \nc1, c2, c3, c4   \nFROM events;\n"})}),"\n",(0,o.jsx)(n.h4,{id:"window-clause",children:"Window clause"}),"\n",(0,o.jsx)(n.p,{children:"The Window clause is used to specify a computational range for window functions. It considers the current row and a specified number of rows before and after it as the target for the window function's operation. The methods supported by the Window clause include: AVG(), COUNT(), FIRST_VALUE(), LAST_VALUE(), and SUM(). For MAX() and MIN(), the Window clause can specify a starting range of UNBOUNDED PRECEDING."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"ROWS BETWEEN [ { m | UNBOUNDED } PRECEDING | CURRENT ROW] [ AND [CURRENT ROW | { UNBOUNDED | n } FOLLOWING] ]\n"})}),"\n",(0,o.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,o.jsx)(n.p,{children:'Taking the following stock data as an example, the stock code is JDR, and the "closing price" refers to the daily closing quotation.'}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"create table stock_ticker (stock_symbol string, closing_price decimal(8,2), closing_date timestamp);    \n...load some data...    \nselect * from stock_ticker order by stock_symbol, closing_date\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-text",children:"| stock_symbol | closing_price | closing_date        |\n|--------------|---------------|---------------------|\n| JDR          | 12.86         | 2014-10-02 00:00:00 |\n| JDR          | 12.89         | 2014-10-03 00:00:00 |\n| JDR          | 12.94         | 2014-10-04 00:00:00 |\n| JDR          | 12.55         | 2014-10-05 00:00:00 |\n| JDR          | 14.03         | 2014-10-06 00:00:00 |\n| JDR          | 14.75         | 2014-10-07 00:00:00 |\n| JDR          | 13.98         | 2014-10-08 00:00:00 |\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This query utilizes a window function to generate the ",(0,o.jsx)(n.code,{children:"moving_average"})," column, which calculates the average stock price over a three-day span, specifically the previous day, the current day, and the next day. Since there is no previous day's data for the first day and no next day's data for the last day, the average is only calculated based on two days for those rows. In this case, the ",(0,o.jsx)(n.code,{children:"Partition By"})," clause is not relevant because all the data pertains to the stock JDR. However, if there was additional stock information, ",(0,o.jsx)(n.code,{children:"Partition By"})," would ensure that the window function operates exclusively within each partition."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"select stock_symbol, closing_date, closing_price,    \navg(closing_price) over (partition by stock_symbol order by closing_date    \nrows between 1 preceding and 1 following) as moving_average    \nfrom stock_ticker;\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-text",children:"| stock_symbol | closing_date        | closing_price | moving_average |\n|--------------|---------------------|---------------|----------------|\n| JDR          | 2014-10-02 00:00:00 | 12.86         | 12.87          |\n| JDR          | 2014-10-03 00:00:00 | 12.89         | 12.89          |\n| JDR          | 2014-10-04 00:00:00 | 12.94         | 12.79          |\n| JDR          | 2014-10-05 00:00:00 | 12.55         | 13.17          |\n| JDR          | 2014-10-06 00:00:00 | 14.03         | 13.77          |\n| JDR          | 2014-10-07 00:00:00 | 14.75         | 14.25          |\n| JDR          | 2014-10-08 00:00:00 | 13.98         | 14.36          |\n"})}),"\n",(0,o.jsx)(n.h3,{id:"see-more",children:"See more"}),"\n",(0,o.jsxs)(n.p,{children:["For more window functions, refer to ",(0,o.jsx)(n.a,{href:"../../sql-manual/sql-functions/window-functions/WINDOW-FUNCTION",children:"Window Functions"})]})]})}function u(e={}){let{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},250065:function(e,n,t){t.d(n,{Z:function(){return r},a:function(){return s}});var i=t(667294);let o={},a=i.createContext(o);function s(e){let n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);